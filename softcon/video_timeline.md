# Mini-KVM 소프트콘 영상 타임라인 (5분)

## 전체 구성 전략
- **스타일**: 혼합 (슬라이드 전환 + 풀스크린 터미널 데모)
- **톤**: 전문적이면서 데모 중심의 밸런스
- **타겟**: 소프트웨어융합대학 학생들 (기본 지식 있음, 설명 필요)
- **핵심 메시지**: QEMU 대비 성능 우위 + 효율적 구현

---

## 세그먼트별 타임라인

### 0:00-0:20 | 인트로 + 훅 (20초)
**형식**: Marp 슬라이드 → 터미널 풀스크린 전환
**내용**:
- 0:00-0:05: 타이틀 슬라이드 "Mini-KVM: 1,500줄로 구현한 완전한 하이퍼바이저"
- 0:05-0:10: "가상화 기술은 복잡해야 할까요?" (QEMU 100K LOC vs Mini-KVM 1.5K LOC 비교)
- 0:10-0:20: **즉시 임팩트** - 4개 vCPU 병렬 실행 터미널 영상
  - `./kvm-vmm guest/counter.bin guest/hello.bin guest/multiplication.bin guest/minimal.bin`
  - 색상별로 출력이 섞이는 것 강조

**대본**:
> "Mini-KVM은 단 1,500줄의 C 코드로 완전한 하이퍼바이저를 구현합니다. 
> 화면에 보이는 것은 4개의 독립적인 가상 머신이 동시에 실행되는 모습입니다. 
> 각 VM은 서로 다른 색상으로 구분되며, 실시간으로 병렬 실행되고 있습니다."

---

### 0:20-1:00 | 문제 정의 + 아키텍처 (40초)
**형식**: Marp 슬라이드
**내용**:
- 0:20-0:35: 문제 제시
  - 전통적 하이퍼바이저의 복잡성 (QEMU 예시)
  - 교육/연구/임베디드 환경에서의 한계
  - "정말 이렇게 복잡해야 할까?"
- 0:35-1:00: Mini-KVM 아키텍처 소개
  - Host → Linux KVM API → Mini-KVM VMM → Guest 구조도
  - 핵심 설계: Hypercall (port 0x500), Conditional IRQCHIP, Per-vCPU Memory Isolation
  - Real Mode (16-bit) + Protected Mode (32-bit) 지원

**대본**:
> "QEMU는 10만 줄이 넘는 코드로 구성되어 있습니다. 초기화에 50ms, 메모리는 50MB 이상 사용합니다.
> 교육이나 임베디드 환경에서는 이러한 복잡성이 오히려 장벽이 됩니다.
> 
> Mini-KVM은 Linux KVM API를 활용해 하드웨어 가상화 기능을 그대로 사용하면서,
> VMM 계층만 최소화했습니다. Hypercall 인터페이스, 조건부 인터럽트 처리,
> vCPU별 메모리 격리 등 핵심 기능을 효율적으로 구현했습니다."

---

### 1:00-2:00 | Real Mode 데모 (1분)
**형식**: 터미널 풀스크린 + 텍스트 오버레이
**내용**:
- 1:00-1:15: 단일 vCPU 빠른 실행 (15초)
  - `./kvm-vmm guest/hello.bin` - "Hello, World!" 즉시 출력
  - `./kvm-vmm guest/minimal.bin` - 1바이트 최소 게스트 (10ms 이하)
  - 오버레이: "초기화 시간: <5ms | 메모리: 1.5MB"
- 1:15-1:40: 멀티 vCPU 병렬성 시연 (25초)
  - `./kvm-vmm guest/multiplication.bin guest/counter.bin`
  - 곱셈표와 카운터가 동시에 실행되며 출력이 섞이는 모습
  - 오버레이: "2 vCPUs | 실시간 병렬 실행 | 문자 단위 unbuffered 출력"
- 1:40-2:00: 4 vCPU 최대 병렬성 (20초)
  - `./kvm-vmm guest/counter.bin guest/hello.bin guest/multiplication.bin guest/fibonacci.bin`
  - 4개 색상이 섞이는 시각적 효과
  - 오버레이: "4 vCPUs | 95% 효율 @ 2 vCPUs, 90% @ 4 vCPUs"

**대본**:
> "Real Mode에서는 16비트 게스트를 실행합니다. 가장 작은 게스트는 단 1바이트로,
> 10ms 이내에 실행이 완료됩니다. 
> 
> 진짜 강점은 멀티 vCPU 병렬 실행입니다. 화면에서 보시는 것처럼 
> 곱셈표를 계산하는 VM과 숫자를 세는 VM이 동시에 실행되고 있습니다.
> 출력은 문자 단위로 섞이며, 이는 진정한 병렬성을 보여줍니다.
> 
> 4개의 vCPU를 동시에 실행해도 90% 이상의 확장성을 유지합니다."

---

### 2:00-3:30 | Protected Mode - 1K OS 데모 (1분 30초)
**형식**: 터미널 풀스크린 (대화형 실행)
**내용**:
- 2:00-2:15: Protected Mode 소개 + 메뉴 표시 (15초)
  - `./kvm-vmm --paging os-1k/kernel.bin`
  - 1K OS 부팅, 9개 프로그램 메뉴 표시
  - 오버레이: "Protected Mode | GDT/IDT | 4MB PSE Paging | Timer + Keyboard IRQ"
- 2:15-2:35: 프로그램 1 - 곱셈표 (20초)
  - 선택 "1", 구구단 2-9단 빠르게 출력
  - 오버레이: "Program 1: Multiplication Table"
- 2:35-2:55: 프로그램 4 - 피보나치 (20초)
  - 선택 "4", 피보나치 수열 계산 및 출력
  - 오버레이: "Program 4: Fibonacci Sequence"
- 2:55-3:15: 프로그램 3 - 에코 (20초)
  - 선택 "3", "Mini-KVM Demo!" 입력 → 에코 출력
  - 오버레이: "Program 3: Echo (Keyboard IRQ + IOPL=3)"
- 3:15-3:30: 프로그램 5 - 소수 (15초)
  - 선택 "5", 100 이하 소수 목록 출력
  - 오버레이: "Program 5: Prime Numbers"

**대본**:
> "Protected Mode에서는 완전한 운영체제를 실행할 수 있습니다.
> 1K OS는 RISC-V에서 x86으로 포팅한 교육용 OS로, 9개의 사용자 프로그램을 포함합니다.
> 
> GDT와 IDT를 설정하고, 4MB PSE 페이징을 활성화했습니다.
> 타이머 인터럽트와 키보드 인터럽트도 정상 동작합니다.
> 
> 곱셈표, 피보나치 수열, 에코 프로그램 등 다양한 작업을 처리할 수 있으며,
> 각 프로그램은 사용자 모드에서 실행되어 커널과 명확히 분리됩니다."

---

### 3:30-4:20 | 성능 비교 + 기술 디테일 (50초)
**형식**: Marp 슬라이드 (차트 + 코드 스니펫)
**내용**:
- 3:30-3:50: 성능 비교 레이더 차트 (20초)
  - `chart_radar.png` 전체 화면 표시
  - 6개 지표: 초기화 시간, 실행 속도, 메모리 사용량, 코드 크기, 확장성, 교육적 가치
  - Mini-KVM이 모든 지표에서 우위 (교육적 가치는 압도적)
- 3:50-4:05: 핵심 혁신 기술 (15초)
  - 코드 스니펫: `init_kvm(bool need_irqchip)` - Conditional IRQCHIP
  - Real Mode는 IRQCHIP 없이 깔끔한 종료, Protected Mode는 인터럽트 지원
- 4:05-4:20: 코드 크기 + 성능 수치 (15초)
  - 슬라이드: "1,500 LOC vs 100,000+ LOC (QEMU)"
  - "초기화: 5ms vs 50ms (10배 빠름)"
  - "실행 속도: 50-100배 빠름 (vs QEMU TCG)"
  - "메모리: 1.5MB vs 50MB (30배 절약)"

**대본**:
> "레이더 차트를 보시면 Mini-KVM의 장점이 명확히 드러납니다.
> 초기화 시간은 10배 빠르고, 실행 속도는 50배에서 100배 빠릅니다.
> 메모리는 30분의 1만 사용하며, 코드 크기는 70분의 1입니다.
> 
> 핵심 혁신 중 하나는 조건부 IRQCHIP 생성입니다.
> Real Mode 게스트는 인터럽트가 필요 없어 IRQCHIP을 만들지 않고,
> Protected Mode만 IRQCHIP을 활성화해 불필요한 오버헤드를 제거했습니다.
> 
> 이 모든 기능을 단 1,500줄의 코드로 구현했습니다."

---

### 4:20-4:50 | 응용 분야 + 가치 제안 (30초)
**형식**: Marp 슬라이드
**내용**:
- 4:20-4:35: 응용 분야 (15초)
  - **교육**: 가상화 개념 학습, 코드 읽기 쉬움
  - **임베디드**: 리소스 제약 환경, 빠른 초기화
  - **연구**: 하이퍼바이저 실험 플랫폼
  - **테스트**: VM 빠른 프로비저닝
- 4:35-4:50: 가치 제안 (15초)
  - "복잡성 없이도 완전한 기능 제공"
  - "오픈소스 (MIT License) - 누구나 학습/수정 가능"
  - "실전 성능 - 교육용이지만 프로덕션 수준 성능"

**대본**:
> "Mini-KVM은 다양한 분야에 활용될 수 있습니다.
> 교육 환경에서는 읽기 쉬운 코드로 가상화를 학습할 수 있고,
> 임베디드 시스템에서는 최소 리소스로 VM을 실행할 수 있습니다.
> 
> 복잡성을 제거했지만 기능은 완전합니다.
> MIT 라이선스로 공개되어 누구나 자유롭게 사용하고 수정할 수 있습니다."

---

### 4:50-5:00 | 클로징 + CTA (10초)
**형식**: Marp 슬라이드 → 터미널 영상 (짧은 반복)
**내용**:
- 4:50-4:55: 4 vCPU 병렬 실행 영상 재등장 (5초)
- 4:55-5:00: 최종 슬라이드 (5초)
  - "Mini-KVM: 완전하고, 빠르고, 교육적인 하이퍼바이저"
  - GitHub 링크 + QR 코드 (`qr.png`)
  - "github.com/seolcu/mini-kvm"

**대본**:
> "Mini-KVM, 가상화의 본질을 1,500줄로 증명합니다.
> 지금 바로 GitHub에서 확인하세요."

---

## 타이밍 요약

| 시간 | 세그먼트 | 형식 | 핵심 |
|------|---------|------|------|
| 0:00-0:20 | 인트로 + 훅 | 슬라이드 + 터미널 | 4 vCPU 병렬 실행 |
| 0:20-1:00 | 문제 + 아키텍처 | 슬라이드 | QEMU 비교, 설계 원리 |
| 1:00-2:00 | Real Mode 데모 | 터미널 | 단일/멀티 vCPU 성능 |
| 2:00-3:30 | Protected Mode 데모 | 터미널 | 1K OS 4개 프로그램 |
| 3:30-4:20 | 성능 + 기술 | 슬라이드 | 레이더 차트, 혁신 |
| 4:20-4:50 | 응용 + 가치 | 슬라이드 | 실전 활용 사례 |
| 4:50-5:00 | 클로징 + CTA | 슬라이드 + 터미널 | GitHub 링크 |

**총 시간**: 5분 (300초)
**터미널 데모**: 2분 30초 (50%)
**슬라이드**: 2분 30초 (50%)
