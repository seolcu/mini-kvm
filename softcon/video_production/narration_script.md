# Mini-KVM 소프트콘 영상 내레이션 대본

## 녹음 가이드
- **톤**: 전문적이지만 친근하게, 명확한 발음
- **속도**: 보통 속도 (분당 150-180 단어), 기술 용어는 천천히
- **강조**: 숫자(성능 지표)와 핵심 메시지 강조
- **호흡**: 각 문단 끝에서 자연스러운 호흡

---

## 0:00-0:25 | 인트로 + 훅
**[슬라이드 1: 타이틀 - Mini-KVM]**

```
안녕하십니까.

자기주도프로젝트를 통해 진행한 Mini-KVM 프로젝트를 발표할 설규원입니다.

[짧은 멈춤]

Mini-KVM은 단 1,500줄의 C 코드로 완전한 하이퍼바이저를 구현합니다.

화면에 보이는 것은 4개의 독립적인 가상 머신이 동시에 실행되는 모습입니다.

각 VM은 서로 다른 색상으로 구분되며, 실시간으로 병렬 실행되고 있습니다.
```

**타이밍 노트**:
- 자연스러운 인사 톤
- "1,500줄" 강조
- "4개의 독립적인" 강조
- "실시간으로 병렬" 강조

---

## 0:25-1:30 | 문제 정의 + 해결책 + 아키텍처
**[슬라이드 2: 가상화 기술은 복잡해야 할까요?]**

```
가상화 기술은 정말 복잡해야만 할까요?

[슬라이드 3: 전통적 하이퍼바이저의 복잡성]

QEMU는 대표적인 하이퍼바이저로, 10만 줄이 넘는 코드로 구성되어 있습니다.

초기화에 50밀리초, 메모리는 50메가바이트 이상을 사용합니다.

[짧은 멈춤]

그런데 교육이나 임베디드 환경에서는 이러한 복잡성이 장벽이 됩니다.

코드를 이해하기 어렵고, 리소스도 과도하게 사용하죠.

[슬라이드 4: Mini-KVM의 접근]

이 문제를 해결하기 위해 Mini-KVM은 세 가지 핵심 원칙을 따릅니다.

첫째, 최소화된 복잡성으로 꼭 필요한 기능만 구현했습니다.

둘째, Linux KVM API를 활용해 하드웨어 가상화 기능을 그대로 사용합니다.

셋째, 읽기 쉬운 1,500줄의 명확한 코드로 작성했습니다.

[짧은 멈춤]

그 결과, 초기화는 10배 빠르고, 실행 속도는 50배에서 100배 빠릅니다.

메모리는 30분의 1만 사용합니다.

[슬라이드 5: 아키텍처 개요]

화면의 아키텍처를 보시면 구조가 명확합니다.

맨 아래 Host Linux Kernel의 KVM 모듈이 하드웨어 가상화를 담당하고,

그 위에 Mini-KVM VMM이 vCPU 관리, 메모리 관리, VM Exit 처리를 수행합니다.

가장 위에는 최대 4개의 게스트 프로그램이 실행됩니다.
```

**타이밍 노트**:
- "가상화 기술은 복잡해야 할까요?" 질문 톤으로
- "10만 줄" vs "1,500줄" 대비 강조
- "그런데" 전환 강조
- 세 가지 원칙 천천히 명확하게
- "KVM API" 천천히 발음
- 아키텍처 설명은 다이어그램을 가리키듯이

---

## 1:30-2:30 | 핵심 설계 혁신 + Real Mode 데모
**[슬라이드 6: 핵심 설계 혁신]**

```
Mini-KVM의 핵심 설계 혁신은 세 가지입니다.

첫째, Conditional IRQCHIP입니다.

Real Mode에서는 IRQCHIP을 만들지 않아 깔끔하게 종료되고,

Protected Mode에서만 IRQCHIP을 활성화해 인터럽트를 지원합니다.

둘째, vCPU별 메모리 격리입니다.

각 vCPU는 독립적인 물리 메모리 영역을 가집니다.

셋째, Hypercall 인터페이스로 Port 0x500을 통해 효율적으로 통신합니다.

[짧은 멈춤]

[데모 시작 - Real Mode 단일 vCPU 5초]

Real Mode에서는 16비트 게스트를 실행합니다.

가장 작은 게스트는 단 1바이트로, 10밀리초 이내에 실행이 완료됩니다.

[데모 시작 - Real Mode 멀티 vCPU 10초]

진짜 강점은 멀티 vCPU 병렬 실행입니다.

화면에서 보시는 것처럼 곱셈표를 계산하는 VM과 숫자를 세는 VM이

동시에 실행되고 있습니다.

[짧은 멈춤]

출력은 문자 단위로 섞이며, 이는 진정한 병렬성을 보여줍니다.

4개의 vCPU를 동시에 실행해도 90% 이상의 확장성을 유지합니다.
```

**타이밍 노트**:
- "1바이트", "10밀리초" 강조
- "동시에 실행" 강조
- "90% 이상" 강조

---

## 2:30-3:40 | Protected Mode - 1K OS 데모
**[슬라이드 계속 또는 데모 화면]**

```
[데모 시작 - Protected Mode 1K OS 실행]

Protected Mode에서는 완전한 운영체제를 실행할 수 있습니다.

1K OS는 RISC-V에서 x86으로 포팅한 교육용 OS로,

9개의 사용자 프로그램을 포함합니다.

[짧은 멈춤]

GDT와 IDT를 설정하고, 4메가바이트 PSE 페이징을 활성화했습니다.

타이머 인터럽트와 키보드 인터럽트도 정상 동작합니다.

[짧은 멈춤]

곱셈표, 피보나치 수열, 에코 프로그램 등 다양한 작업을 처리할 수 있으며,

각 프로그램은 사용자 모드에서 실행되어 커널과 명확히 분리됩니다.

[데모 진행 중 - 20초간 프로그램 실행, 내레이션 없이 타이핑/실행 소리만]
```

**타이밍 노트**:
- "Protected Mode" 명확히 발음
- "GDT", "IDT", "PSE" 천천히
- "9개의 사용자 프로그램" 강조
- 데모 실행 중 20초는 무음 (키보드 타이핑과 출력만)

---

## 3:40-4:40 | 성능 비교 + 코드 스니펫
**[슬라이드 7: 성능 비교 레이더 차트]**

```
레이더 차트를 보시면 Mini-KVM의 장점이 명확히 드러납니다.

초기화 시간은 10배 빠르고, 실행 속도는 50배에서 100배 빠릅니다.

메모리는 30분의 1만 사용하며, 코드 크기는 70분의 1입니다.

확장성도 90% 이상으로 우수하고, 교육적 가치는 압도적입니다.

[슬라이드 8: 코드 스니펫 - Conditional IRQCHIP]

화면의 코드를 보시면, 핵심 혁신인 조건부 IRQCHIP이 어떻게 구현되는지 알 수 있습니다.

Real Mode 게스트는 인터럽트가 필요 없어 IRQCHIP을 만들지 않고,

Protected Mode에서만 IRQCHIP을 활성화해 불필요한 오버헤드를 제거했습니다.

[짧은 멈춤]

[슬라이드 9: 성능 수치 요약 테이블]

이 모든 기능을 단 1,500줄의 코드로 구현했습니다.
```

**타이밍 노트**:
- 숫자 강조: "10배", "50배에서 100배", "30분의 1", "70분의 1"
- "조건부 IRQCHIP" 강조
- 마지막 "1,500줄" 힘주어 발음

---

## 4:40-5:10 | 응용 분야 + 가치 제안
**[슬라이드 10: 응용 분야]**

```
Mini-KVM은 다양한 분야에 활용될 수 있습니다.

교육 환경에서는 읽기 쉬운 코드로 가상화를 학습할 수 있고,

임베디드 시스템에서는 최소 리소스로 VM을 실행할 수 있습니다.

연구 분야에서는 하이퍼바이저 실험 플랫폼으로 사용할 수 있으며,

빠른 테스트가 필요한 곳에서는 VM을 즉시 프로비저닝할 수 있습니다.

[슬라이드 12: 가치 제안]

복잡성을 제거했지만 기능은 완전합니다.

교육용이지만 실전 성능을 갖추고 있습니다.

MIT 라이선스로 공개되어 누구나 자유롭게 사용하고 수정할 수 있습니다.
```

**타이밍 노트**:
- "교육", "임베디드" 강조
- "완전합니다" 강조
- "MIT 라이선스" 명확히

---

## 5:10-5:20 | 클로징 + CTA
**[슬라이드 13: 최종 - Mini-KVM 타이틀 + QR 코드]**

```
Mini-KVM,

가상화의 본질을 1,500줄로 증명합니다.

[짧은 멈춤]

지금 바로 GitHub에서 확인하세요.

[슬라이드 14: Thank You]

경청해 주셔서 감사합니다.
```

**타이밍 노트**:
- "Mini-KVM" 후 짧은 멈춤으로 강조
- "1,500줄" 다시 한번 강조
- "GitHub" 명확하게 발음
- 마무리 인사 추가

---

## 전체 대본 (연속 버전 - 녹음용)

```
안녕하십니까.
자기주도프로젝트를 통해 진행한 Mini-KVM 프로젝트를 발표할 설규원입니다.

Mini-KVM은 단 1,500줄의 C 코드로 완전한 하이퍼바이저를 구현합니다.
화면에 보이는 것은 4개의 독립적인 가상 머신이 동시에 실행되는 모습입니다.
각 VM은 서로 다른 색상으로 구분되며, 실시간으로 병렬 실행되고 있습니다.

가상화 기술은 정말 복잡해야만 할까요?

QEMU는 대표적인 하이퍼바이저로, 10만 줄이 넘는 코드로 구성되어 있습니다.
초기화에 50밀리초, 메모리는 50메가바이트 이상을 사용합니다.

그런데 교육이나 임베디드 환경에서는 이러한 복잡성이 장벽이 됩니다.
코드를 이해하기 어렵고, 리소스도 과도하게 사용하죠.

이 문제를 해결하기 위해 Mini-KVM은 세 가지 핵심 원칙을 따릅니다.

첫째, 최소화된 복잡성으로 꼭 필요한 기능만 구현했습니다.
둘째, Linux KVM API를 활용해 하드웨어 가상화 기능을 그대로 사용합니다.
셋째, 읽기 쉬운 1,500줄의 명확한 코드로 작성했습니다.

그 결과, 초기화는 10배 빠르고, 실행 속도는 50배에서 100배 빠릅니다.
메모리는 30분의 1만 사용합니다.

화면의 아키텍처를 보시면 구조가 명확합니다.
맨 아래 Host Linux Kernel의 KVM 모듈이 하드웨어 가상화를 담당하고,
그 위에 Mini-KVM VMM이 vCPU 관리, 메모리 관리, VM Exit 처리를 수행합니다.
가장 위에는 최대 4개의 게스트 프로그램이 실행됩니다.

Mini-KVM의 핵심 설계 혁신은 세 가지입니다.

첫째, Conditional IRQCHIP입니다.
Real Mode에서는 IRQCHIP을 만들지 않아 깔끔하게 종료되고,
Protected Mode에서만 IRQCHIP을 활성화해 인터럽트를 지원합니다.

둘째, vCPU별 메모리 격리입니다.
각 vCPU는 독립적인 물리 메모리 영역을 가집니다.

셋째, Hypercall 인터페이스로 Port 0x500을 통해 효율적으로 통신합니다.

Real Mode에서는 16비트 게스트를 실행합니다.
가장 작은 게스트는 단 1바이트로, 10밀리초 이내에 실행이 완료됩니다.

진짜 강점은 멀티 vCPU 병렬 실행입니다.
화면에서 보시는 것처럼 곱셈표를 계산하는 VM과 숫자를 세는 VM이
동시에 실행되고 있습니다.

출력은 문자 단위로 섞이며, 이는 진정한 병렬성을 보여줍니다.
4개의 vCPU를 동시에 실행해도 90% 이상의 확장성을 유지합니다.

Protected Mode에서는 완전한 운영체제를 실행할 수 있습니다.
1K OS는 RISC-V에서 x86으로 포팅한 교육용 OS로,
9개의 사용자 프로그램을 포함합니다.

GDT와 IDT를 설정하고, 4메가바이트 PSE 페이징을 활성화했습니다.
타이머 인터럽트와 키보드 인터럽트도 정상 동작합니다.

곱셈표, 피보나치 수열, 에코 프로그램 등 다양한 작업을 처리할 수 있으며,
각 프로그램은 사용자 모드에서 실행되어 커널과 명확히 분리됩니다.

레이더 차트를 보시면 Mini-KVM의 장점이 명확히 드러납니다.
초기화 시간은 10배 빠르고, 실행 속도는 50배에서 100배 빠릅니다.
메모리는 30분의 1만 사용하며, 코드 크기는 70분의 1입니다.
확장성도 90% 이상으로 우수하고, 교육적 가치는 압도적입니다.

화면의 코드를 보시면, 핵심 혁신인 조건부 IRQCHIP이 어떻게 구현되는지 알 수 있습니다.
Real Mode 게스트는 인터럽트가 필요 없어 IRQCHIP을 만들지 않고,
Protected Mode에서만 IRQCHIP을 활성화해 불필요한 오버헤드를 제거했습니다.

이 모든 기능을 단 1,500줄의 코드로 구현했습니다.

Mini-KVM은 다양한 분야에 활용될 수 있습니다.
교육 환경에서는 읽기 쉬운 코드로 가상화를 학습할 수 있고,
임베디드 시스템에서는 최소 리소스로 VM을 실행할 수 있습니다.
연구 분야에서는 하이퍼바이저 실험 플랫폼으로 사용할 수 있으며,
빠른 테스트가 필요한 곳에서는 VM을 즉시 프로비저닝할 수 있습니다.

복잡성을 제거했지만 기능은 완전합니다.
교육용이지만 실전 성능을 갖추고 있습니다.
MIT 라이선스로 공개되어 누구나 자유롭게 사용하고 수정할 수 있습니다.

Mini-KVM, 가상화의 본질을 1,500줄로 증명합니다.
지금 바로 GitHub에서 확인하세요.

경청해 주셔서 감사합니다.
```

**총 단어 수**: 약 650단어 (한국어 기준)
**예상 녹음 시간**: 약 4분 30초 (데모 중 20-30초 무음 포함 시 총 5분 내외)

---

## 녹음 팁

1. **사전 연습**: 전체 대본을 3-5회 읽어보며 호흡과 속도 조절
2. **발음 체크**: 
   - KVM → "케이비엠" (각 글자 명확히)
   - QEMU → "퀘뮤"
   - vCPU → "브이씨피유"
   - IRQCHIP → "아이알큐칩"
   - PSE → "피에스이"
3. **감정**: 열정적이지만 과하지 않게, 자신감 있게
4. **배경 소음**: 조용한 환경, 마이크 가까이
5. **편집 여유**: 각 세그먼트 전후 2초 여유 (편집 용이)
6. **실수 대응**: 실수 시 멈추지 말고 해당 문장 처음부터 다시 (편집에서 잘라냄)
