# 9주차 상담내용 (10/28)

1. 프로젝트 개요

- 목표: RISC-V 아키텍처 기반의 하이퍼바이저(HV) 개발
- 주요 제약:
  - 개발 호스트 환경: x86
  - 프로젝트 기한: 약 1개월 (소프트콘)

2. 기존 계획 (x86 네이티브) 검토

- 내용: x86 호스트에서 직접 실행되는 마이크로 VMM(하이퍼바이저) 개발
- 문제점: x86 아키텍처의 높은 복잡성 (메모리 페이징, 디바이스 및 인터럽트 초기화 등)으로 인해 1개월 내 구현 불가능하다고 판단
- 결론: x86 네이티브 하이퍼바이저 개발 계획 폐기

3. 변경된 아키텍처 (RISC-V 에뮬레이션)

- 구성 (첨부 이미지 참조):
  - Host: x86 (실제 하드웨어)
  - 에뮬레이터: Qemu (RISC-V 환경 에뮬레이션)
  - 에뮬레이트된 OS: Linux (RISC-V 버전, KVM 모듈 포함)
  - 개발 대상: 하이퍼바이저 (HV) (RISC-V 리눅스 상에서 실행)
  - Guest OS: Toy OS 또는 Xv6 (개발 HV 상에서 실행)
- 특징: Qemu로 RISC-V 환경을 구성하고, 그 안의 리눅스 KVM 기능을 활용하는 방식

4. 핵심 개발 과제

- 목표: Guest OS가 발생시킨 하이퍼콜(Hypercall)을 개발 HV가 수신
- 처리: 수신된 하이퍼콜을 Qemu 내 RISC-V 리눅스의 KVM 모듈로 전달 및 처리
- 구현 방안:
  - 개발 HV가 Qemu 내 리눅스의 KVM 인터페이스(/dev/kvm)를 사용.
  - Guest OS의 하이퍼콜을 KVM ioctl 호출 (VCPU 생성/실행, 메모리 설정 등)로 변환하는 '브릿지' 역할 수행.
  - 필요시 Qemu의 KVM API 사용 방식(소스 코드) 참조.

5. 세부 실행 계획 (To-Do)

- 기본 환경 구축: x86 호스트에 Qemu를 설치하고, 그 위에 RISC-V 리눅스(KVM 포함)를 실행.
- Guest OS 구현: 하이퍼콜을 호출하는 간단한 Guest OS (Toy OS) 코드 준비 (기존 작업분 활용).
- HV-KVM 브릿지 구현 (핵심):
  - RISC-V 리눅스 환경에서 /dev/kvm을 열어 VCPU를 생성.
  - Guest OS의 하이퍼콜을 받아 KVM을 통해 VCPU 상태(레지스터 등)를 가져오고 실행을 관리하는 기능 구현.
