# Mini-KVM 최종 프로젝트 보고서 (요약)

**프로젝트명**: Mini-KVM: 교육용 x86 가상 머신 모니터  
**개발 기간**: 2025년 9월 - 2025년 11월 (13주)  
**최종 수정**: 2025년 11월 23일  
**팀**: Seolcu (개인 프로젝트)

---

## 1. 핵심 요약 (Executive Summary)

Mini-KVM은 교육 목적으로 처음부터 개발된, 최소한의 기능으로 완전하게 동작하는 x86 아키텍처용 KVM 기반 가상 머신 모니터(VMM)입니다. 이 프로젝트는 다중 vCPU 실행, 인터럽트 처리, 메모리 관리, I/O 에뮬레이션을 포함한 핵심 가상화 개념을 성공적으로 시연합니다. VMM은 리얼 모드(16비트)와 보호 모드(32비트) 게스트를 모두 지원하며, 9개의 대화형 사용자 프로그램을 갖춘 맞춤형 '1K OS' 커널을 포함합니다.

**주요 성과**:
- 1,400줄의 C 코드로 모든 기능이 동작하는 VMM 구현
- 다중 vCPU 지원 (최대 4개 동시 실행)
- 완전한 인터럽트 인프라 (타이머 + 키보드)
- 페이징 및 프로세스 관리가 포함된 보호 모드 커널
- 6개의 리얼 모드 게스트 + 9개의 보호 모드 프로그램
- 게스트-호스트 통신을 위한 포괄적인 하이퍼콜 인터페이스
- QEMU TCG 에뮬레이션 대비 50-100배의 성능 향상

---

## 2. 아키텍처

### 2.1 VMM 아키텍처

**핵심 구성요소**:

1.  **VM 초기화** (약 150줄)
    - `/dev/kvm`을 통해 VM 생성
    - 게스트 메모리 설정 (vCPU당 4MB, 최대 16MB)
    - 리얼/보호 모드를 위한 CPUID, SREGS, REGS 구성

2.  **vCPU 관리** (약 300줄)
    - `pthread`를 사용한 vCPU별 스레드 모델
    - vCPU 상태 추적 (실행/중지)
    - 색상 코드가 포함된 스레드 안전 콘솔 출력

3.  **메모리 관리** (약 100줄)
    - 1K OS를 위한 게스트 페이지 테이블 구성
    - 보호 모드에서 4MB PSE 페이지를 사용한 2단계 페이징
    - vCPU별 메모리 격리 (주소 오프셋 기반)

4.  **하이퍼콜 인터페이스** (약 200줄)
    - 0x500 포트에서의 I/O 트랩 (OUT 명령어)
    - `HC_EXIT` (0x00): 게스트 종료
    - `HC_PUTCHAR` (0x01): 콘솔 출력
    - `HC_GETCHAR` (0x02): 키보드 입력

5.  **인터럽트 주입** (약 250줄)
    - 타이머 스레드 (10ms 주기, IRQ0)
    - 키보드 모니터 스레드 (stdin 폴링)
    - `KVM_INTERRUPT` API를 통한 인터럽트 전달

6.  **VM Exit 처리** (약 400줄)
    - MMIO/PIO, 하이퍼콜, HLT 명령어 처리
    - 종료 및 오류 처리

### 2.2 게스트 아키텍처

- **리얼 모드 게스트**: 16비트 코드로, 세그먼트:오프셋 주소 지정을 사용합니다. `minimal.S`(1바이트)부터 `multiplication.S`(112바이트)까지 총 6개의 테스트 프로그램이 있습니다.
- **보호 모드 게스트 (1K OS)**: 페이징이 적용된 32비트 커널입니다. 커널은 초기화, 간단한 라운드-로빈 스케줄러, 메모리 할당자 등을 포함하며, 9개의 사용자 프로그램을 내장한 셸을 실행합니다.

---

## 3. 주요 개선 사항 (최종 개발 단계)

### 3.1 Real Mode 게스트 Hang 문제 해결 (2025-11-23)

**문제 발견**:
- Real Mode 게스트가 HLT 명령어 실행 후 종료되지 않고 무한정 대기
- 타이머 인터럽트(IRQ0)가 100ms마다 HLT 상태의 vCPU를 깨움
- 인터럽트가 필요 없는 Real Mode에서도 IRQCHIP이 활성화되어 있었음

**근본 원인 분석**:
- `init_kvm()` 함수에서 모든 모드(Real/Protected)에 대해 IRQCHIP 생성
- Timer 및 stdin 모니터 스레드가 모든 모드에서 실행
- Real Mode 게스트는 인터럽트를 처리할 수 없으므로, IRQ0가 단순히 HLT를 중단시키고 재진입만 반복

**해결 방법**:
1. `init_kvm(bool need_irqchip)` 파라미터 추가
2. Protected Mode (`--paging` 플래그)에서만 IRQCHIP 생성
3. Timer/stdin 스레드도 Protected Mode에서만 시작
4. Real Mode는 하이퍼콜만 사용하여 I/O 처리

**결과**:
- Real Mode 게스트가 즉시 종료 (< 100ms)
- Protected Mode는 기존처럼 인터럽트 기반 동작
- 코드 간결화 및 모드별 명확한 책임 분리

관련 커밋: `kvm-vmm-x86/src/main.c:128`, `kvm-vmm-x86/src/main.c:578`

---

### 3.2 출력 시스템 개선

#### 단일/다중 vCPU 출력 구분
**개선 전**: 
- 모든 경우에 색상 코드 적용
- 단일 vCPU에서도 불필요한 색상 출력

**개선 후**:
- **단일 vCPU**: 깔끔한 `[guest_name]` 프리픽스, 색상 없음
- **다중 vCPU**: 각 vCPU를 색상으로 구분 (청록/초록/노랑/파랑)

**색상 선택 개선**:
- vCPU 0을 빨강(Red)에서 청록(Cyan)으로 변경
- 이유: 빨강은 오류 메시지로 오인될 가능성이 있음
- 청록/초록/노랑/파랑은 중립적이고 구분이 명확함

#### 버퍼링 제거
**개선 전**: 
- 줄 단위 버퍼링 (`setvbuf(_IOLBF)`)
- 다중 vCPU의 병렬 실행 효과가 덜 명확

**개선 후**:
- Character-by-character 즉시 출력
- 다중 vCPU 출력이 실시간으로 인터리브되어 병렬성 극대화
- 시각적으로 더 인상적인 데모 효과

관련 함수: `vcpu_printf()`, `vcpu_putchar()` in `main.c:95-135`

---

### 3.3 Verbose 모드 추가

**기능**:
- `--verbose` 플래그로 상세 디버깅 로그 활성화
- VM exit 원인, I/O 포트 접근, 하이퍼콜 상세 정보 출력

**효과**:
- 일반 사용자: 깔끔한 출력 (게스트 출력만)
- 개발자/디버거: 전체 VMM 동작 추적 가능
- 교육 목적으로 VMM 내부 동작 이해에 유용

**특별한 처리**:
- `HC_GETCHAR` (IN) 하이퍼콜은 verbose 모드에서도 억제
- 이유: 1K OS에서 너무 빈번하게 호출되어 출력이 범람

관련 변수: `verbose` (global), 적용: `main.c:170-420`

---

### 3.4 실행 방식 개선

**이전 방식**:
```bash
make run-hello
make run-multi-2
```

**현재 방식**:
```bash
./kvm-vmm guest/hello.bin
./kvm-vmm guest/multiplication.bin guest/counter.bin
./kvm-vmm --paging os-1k/kernel.bin
./kvm-vmm --verbose --paging os-1k/kernel.bin
```

**장점**:
- 더 직관적이고 유연한 사용법
- 플래그 조합 가능 (`--verbose`, `--paging`)
- 임의의 게스트 조합 실행 가능
- Makefile에 의존하지 않음

---

## 4. 향후 연구

### 4.1 구조적 발전 방향 (프로젝트 분석 이후)

프로젝트 분석 결과, 이 저장소는 서로 다른 목표와 완성도를 가진 세 개의 구성요소로 이루어져 있음이 밝혀졌습니다. 다음은 이를 바탕으로 권장되는 장기적인 구조적 발전 경로입니다.

1.  **C-VMM을 64비트(Long Mode) 지원으로 확장**
    *   **목표**: 메인 프로젝트의 가장 직접적인 발전 경로. 안정적인 C-VMM을 64비트 게스트를 지원하도록 확장합니다.
    *   **주요 단계**:
        *   Long Mode 설정 (CR0, CR4, EFER MSR) 구현.
        *   4단계 페이지 테이블(PML4) 생성 및 관리.
        *   64비트 코드 세그먼트를 위한 세그먼트 레지스터 처리 업데이트.
    *   **결과**: 이를 통해 VMM이 실험적인 `HLeOs` 커널을 실행할 수 있게 되어, C와 Rust x86 프로젝트를 통합하고 VMM의 기능을 크게 향상시킬 수 있습니다.

2.  **Rust 프로젝트 분리 및 집중 개발**
    *   **목표**: 실험적인 Rust 프로젝트들이 독립적으로 성숙할 수 있도록 합니다.
    *   **주요 단계**:
        *   **`HLeOs`**: 64비트 OS를 전용 저장소로 이전합니다. QEMU와 같은 표준 하이퍼바이저나, 최종적으로는 64비트가 활성화된 C-VMM에서 실행하는 것을 목표로 개발을 계속합니다.
        *   **`hypervisor`**: 실험적인 RISC-V 하이퍼바이저를 별도의 저장소로 이전합니다. 이를 통해 x86이 아닌 RISC-V라는 고유한 아키텍처를 명확히 하고, 임베디드/RISC-V 분야에 집중된 개발을 할 수 있습니다.

### 4.2 단기 개선 사항 (1-2주)

1.  **전체 키보드 지원**: 전체 스캔코드 변환 테이블 구현.
2.  **디스크 I/O 에뮬레이션**: 파일 기반의 간단한 블록 디바이스 구현.
3.  **성능 최적화**: `eventfd`를 사용하여 인터럽트 지연 시간 단축.

### 4.3 중장기 목표 (1-2개월 이상)

1.  **그래픽 출력**: 메모리 매핑된 비디오 RAM을 통한 간단한 프레임버퍼 구현.
2.  **네트워크 인터페이스**: TAP 디바이스 통합.
3.  **게스트 SMP 지원**: vCPU 간 공유 메모리 및 프로세서 간 인터럽트(IPI) 구현.
4.  **리눅스 부팅**: GRUB, IDE/SATA, VGA, PCI 버스 에뮬레이션을 통해 전체 리눅스 커널 부팅.
