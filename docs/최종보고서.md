# Mini-KVM 최종 프로젝트 보고서 (요약)

**프로젝트명**: Mini-KVM: 교육용 x86 가상 머신 모니터  
**개발 기간**: 2025년 9월 - 2025년 11월 (13주)  
**최종 수정**: 2025년 11월 23일  
**팀**: Seolcu (개인 프로젝트)

---

## 1. 핵심 요약 (Executive Summary)

Mini-KVM은 교육 목적으로 처음부터 개발된, 최소한의 기능으로 완전하게 동작하는 x86 아키텍처용 KVM 기반 가상 머신 모니터(VMM)입니다. 이 프로젝트는 다중 vCPU 실행, 인터럽트 처리, 메모리 관리, I/O 에뮬레이션을 포함한 핵심 가상화 개념을 성공적으로 시연합니다. VMM은 리얼 모드(16비트)와 보호 모드(32비트) 게스트를 모두 지원하며, 9개의 대화형 사용자 프로그램을 갖춘 맞춤형 '1K OS' 커널을 포함합니다.

**주요 성과**:
- 1,400줄의 C 코드로 모든 기능이 동작하는 VMM 구현
- 다중 vCPU 지원 (최대 4개 동시 실행)
- 완전한 인터럽트 인프라 (타이머 + 키보드)
- 페이징 및 프로세스 관리가 포함된 보호 모드 커널
- 6개의 리얼 모드 게스트 + 9개의 보호 모드 프로그램
- 게스트-호스트 통신을 위한 포괄적인 하이퍼콜 인터페이스
- QEMU TCG 에뮬레이션 대비 50-100배의 성능 향상

---

## 2. 아키텍처

### 2.1 VMM 아키텍처

**핵심 구성요소**:

1.  **VM 초기화** (약 150줄)
    - `/dev/kvm`을 통해 VM 생성
    - 게스트 메모리 설정 (vCPU당 4MB, 최대 16MB)
    - 리얼/보호 모드를 위한 CPUID, SREGS, REGS 구성

2.  **vCPU 관리** (약 300줄)
    - `pthread`를 사용한 vCPU별 스레드 모델
    - vCPU 상태 추적 (실행/중지)
    - 색상 코드가 포함된 스레드 안전 콘솔 출력

3.  **메모리 관리** (약 100줄)
    - 1K OS를 위한 게스트 페이지 테이블 구성
    - 보호 모드에서 4MB PSE 페이지를 사용한 2단계 페이징
    - vCPU별 메모리 격리 (주소 오프셋 기반)

4.  **하이퍼콜 인터페이스** (약 200줄)
    - 0x500 포트에서의 I/O 트랩 (OUT 명령어)
    - `HC_EXIT` (0x00): 게스트 종료
    - `HC_PUTCHAR` (0x01): 콘솔 출력
    - `HC_GETCHAR` (0x02): 키보드 입력

5.  **인터럽트 주입** (약 250줄)
    - 타이머 스레드 (10ms 주기, IRQ0)
    - 키보드 모니터 스레드 (stdin 폴링)
    - `KVM_INTERRUPT` API를 통한 인터럽트 전달

6.  **VM Exit 처리** (약 400줄)
    - MMIO/PIO, 하이퍼콜, HLT 명령어 처리
    - 종료 및 오류 처리

### 2.2 게스트 아키텍처

- **리얼 모드 게스트**: 16비트 코드로, 세그먼트:오프셋 주소 지정을 사용합니다. `minimal.S`(1바이트)부터 `multiplication.S`(112바이트)까지 총 6개의 테스트 프로그램이 있습니다.
- **보호 모드 게스트 (1K OS)**: 페이징이 적용된 32비트 커널입니다. 커널은 초기화, 간단한 라운드-로빈 스케줄러, 메모리 할당자 등을 포함하며, 9개의 사용자 프로그램을 내장한 셸을 실행합니다.

---

## 3. 향후 연구

### 3.1 구조적 발전 방향 (프로젝트 분석 이후)

프로젝트 분석 결과, 이 저장소는 서로 다른 목표와 완성도를 가진 세 개의 구성요소로 이루어져 있음이 밝혀졌습니다. 다음은 이를 바탕으로 권장되는 장기적인 구조적 발전 경로입니다.

1.  **C-VMM을 64비트(Long Mode) 지원으로 확장**
    *   **목표**: 메인 프로젝트의 가장 직접적인 발전 경로. 안정적인 C-VMM을 64비트 게스트를 지원하도록 확장합니다.
    *   **주요 단계**:
        *   Long Mode 설정 (CR0, CR4, EFER MSR) 구현.
        *   4단계 페이지 테이블(PML4) 생성 및 관리.
        *   64비트 코드 세그먼트를 위한 세그먼트 레지스터 처리 업데이트.
    *   **결과**: 이를 통해 VMM이 실험적인 `HLeOs` 커널을 실행할 수 있게 되어, C와 Rust x86 프로젝트를 통합하고 VMM의 기능을 크게 향상시킬 수 있습니다.

2.  **Rust 프로젝트 분리 및 집중 개발**
    *   **목표**: 실험적인 Rust 프로젝트들이 독립적으로 성숙할 수 있도록 합니다.
    *   **주요 단계**:
        *   **`HLeOs`**: 64비트 OS를 전용 저장소로 이전합니다. QEMU와 같은 표준 하이퍼바이저나, 최종적으로는 64비트가 활성화된 C-VMM에서 실행하는 것을 목표로 개발을 계속합니다.
        *   **`hypervisor`**: 실험적인 RISC-V 하이퍼바이저를 별도의 저장소로 이전합니다. 이를 통해 x86이 아닌 RISC-V라는 고유한 아키텍처를 명확히 하고, 임베디드/RISC-V 분야에 집중된 개발을 할 수 있습니다.

### 3.2 단기 개선 사항 (1-2주)

1.  **전체 키보드 지원**: 전체 스캔코드 변환 테이블 구현.
2.  **디스크 I/O 에뮬레이션**: 파일 기반의 간단한 블록 디바이스 구현.
3.  **성능 최적화**: `eventfd`를 사용하여 인터럽트 지연 시간 단축.

### 3.3 중장기 목표 (1-2개월 이상)

1.  **그래픽 출력**: 메모리 매핑된 비디오 RAM을 통한 간단한 프레임버퍼 구현.
2.  **네트워크 인터페이스**: TAP 디바이스 통합.
3.  **게스트 SMP 지원**: vCPU 간 공유 메모리 및 프로세서 간 인터럽트(IPI) 구현.
4.  **리눅스 부팅**: GRUB, IDE/SATA, VGA, PCI 버스 에뮬레이션을 통해 전체 리눅스 커널 부팅.
