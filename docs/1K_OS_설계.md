# 1K OS x86 포팅 설계 문서 (Historical)

> **⚠️ 주의**: 이 문서는 1K OS의 **초기 설계 단계**에서 작성된 문서입니다.  
> 실제 구현과 일부 차이가 있을 수 있으므로, 최신 정보는 다음 문서를 참조하세요:
> - 현재 구동 방법: [데모가이드.md](데모가이드.md)
> - 프로젝트 전체: [최종보고서.md](최종보고서.md)
> - 실제 코드: `kvm-vmm-x86/os-1k/` 디렉토리
>
> **주요 차이점**:
> - 시스템 콜 번호: 문서는 `SYS_*` 사용, 실제 구현은 `HC_*` (Hypercall) 사용
> - VMM 수정사항: 이미 구현 완료된 내용이 "필요한 변경사항"으로 표현됨

---

## 개요

"1000줄 운영체제" (RISC-V RV32 기반)를 x86 보호 모드(32비트)로 포팅하여 KVM VMM에서 실행하기 위한 **초기 설계 문서**입니다.

## 메모리 레이아웃

### 물리 메모리 (게스트 물리 주소)
```
0x00000000 - 0x00000FFF (4KB):   Null 페이지 (안전성을 위해 매핑되지 않음)
0x00001000 - 0x00100FFF (1MB):   커널 코드 + 데이터 + BSS
0x00101000 - 0x00102FFF (8KB):   커널 스택
0x00103000 - 0x003FFFFF (~3MB):  페이지 할당을 위한 여유 RAM
0x00400000 - 0x00FFFFFF (12MB):  향후 확장을 위해 예약됨
```

### 가상 메모리 (32비트, 2단계 페이징)
```
0x00000000 - 0x7FFFFFFF (2GB):   사용자 공간
  0x01000000 (USER_BASE):        사용자 프로그램 진입점
0x80000000 - 0xFFFFFFFF (2GB):   커널 공간 (물리 메모리와 동일하게 매핑)
  0x80000000:                    커널 베이스 (물리 주소 0x00000000에 매핑)
```

## 아키텍처 변환

### 레지스터 매핑

| RISC-V | x86 | 목적 |
|--------|-----|---------|
| a0-a2  | EBX, ECX, EDX | 시스템 콜 인자 |
| a3     | EAX | 시스템 콜 번호 |
| ra     | 스택의 반환 주소 | 반환 주소 |
| sp     | ESP | 스택 포인터 |
| s0-s11 | 스택에 푸시 | 호출된 함수가 보존해야 하는 레지스터 |

### 시스템 콜 인터페이스

**RISC-V 원본:**
- 명령어: `ecall`
- 번호: `a3` 레지스터
- 인자: `a0`, `a1`, `a2`

**x86 포팅 (하이퍼콜 기반):**
- 명령어: `out %al, $0x500`
- 번호: `EAX` 레지스터
- 인자: `EBX`, `ECX`, `EDX`

**시스템 콜 번호:**
```c
#define SYS_PUTCHAR     1  // EBX = 문자
#define SYS_GETCHAR     2  // EAX에 문자 반환
#define SYS_EXIT        3  // 프로세스 종료
#define SYS_READFILE    4  // EBX=파일명, ECX=버퍼, EDX=길이
#define SYS_WRITEFILE   5  // EBX=파일명, ECX=버퍼, EDX=길이
```

### 컨텍스트 스위칭 변환

**RISC-V:**
```asm
switch_context:
    addi sp, sp, -52
    sw ra,  0(sp)
    ...
    sw sp, (a0)
    lw sp, (a1)
    ...
    ret
```

**x86 변환:**
```asm
switch_context:
    pushl %ebx
    pushl %esi
    pushl %edi
    pushl %ebp
    movl 20(%esp), %eax
    movl %esp, (%eax)
    movl 24(%esp), %eax
    movl (%eax), %esp
    popl %ebp
    ...
    ret
```

## VMM 수정 사항

### `src/main.c`에 필요한 변경 사항

1.  **페이징 지원 추가**: 게스트 페이지 테이블(페이지 디렉토리)을 설정하고, 커널 공간을 물리 메모리에 매핑합니다.
2.  **게스트에서 페이징 활성화**: `setup_vcpu_context()`에서 `CR3` 레지스터에 페이지 디렉토리 주소를 설정하고, `CR0` 레지스터의 페이징 비트(PG)를 활성화합니다.
3.  **시스템 콜 하이퍼콜 처리**: `KVM_EXIT_IO` 발생 시, 포트 번호와 레지스터 값(EAX)을 확인하여 해당하는 시스템 콜을 VMM에서 처리합니다.

## 부트 시퀀스

### x86 `boot.S`
```asm
.code32
.section .text.boot
.global _start

_start:
    # 세그먼트 설정
    movl $0x10, %eax
    movl %eax, %ds
    ...
    # 스택 설정
    movl $__stack_top, %esp

    # BSS 영역 초기화
    ...
    
    # kernel_main으로 점프
    call kernel_main

1:  hlt
    jmp 1b
```

## 빌드 과정

1. 셸 바이너리 빌드 (`shell.bin`)
2. 셸 바이너리를 오브젝트 파일로 임베딩 (`shell.bin.o`)
3. 커널 소스 컴파일 및 링크
4. 최종 커널 바이너리 추출 (`kernel.bin`)

## 테스트 전략

- **1단계: 부팅 테스트**: 커널이 부팅되고 "Hello" 메시지를 출력하는지 확인합니다.
- **2단계: 메모리 테스트**: 페이지 할당 및 매핑이 정상적으로 동작하는지 확인합니다.
- **3단계: 프로세스 테스트**: 프로세스 생성 및 컨텍스트 스위칭이 동작하는지 확인합니다.
- **4단계: 시스템 콜 테스트**: 모든 시스템 콜이 사용자 프로세스에서 정상적으로 동작하는지 확인합니다.
- **5단계: 셸 테스트**: 셸이 부팅되고 내장된 명령어들이 실행되는지 확인합니다.