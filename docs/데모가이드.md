# Mini-KVM 데모 가이드

발표 시 직접 시연할 수 있는 완전한 가이드입니다.

---

## 사전 준비

### 1. 디렉토리 이동
```bash
cd ~/문서/코드/mini-kvm/kvm-vmm-x86
```

### 2. 프로젝트 빌드

모든 VMM, 게스트 프로그램 및 1K OS는 `make` 명령을 사용하여 빌드하고 실행할 수 있습니다.
`make all` 명령으로 모든 구성요소를 한 번에 빌드할 수 있습니다.

```bash
# 모든 구성요소 빌드 (VMM, 게스트, 1K OS)
make all
```

**빌드 확인**:

```bash
ls -lh kvm-vmm guest/*.bin os-1k/*.bin
```

**예상 결과**:
```
-rwxr-xr-x. 1 seolcu seolcu 25K 11월 23일  HH:MM kvm-vmm
-rwxr-xr-x. 1 seolcu seolcu 18  11월 23일  HH:MM guest/counter.bin
-rwxr-xr-x. 1 seolcu seolcu 82  11월 23일  HH:MM guest/fibonacci.bin
-rwxr-xr-x. 1 seolcu seolcu 79  11월 23일  HH:MM guest/hctest.bin
-rwxr-xr-x. 1 seolcu seolcu 33  11월 23일  HH:MM guest/hello.bin
-rwxr-xr-x. 1 seolcu seolcu 1   11월 23일  HH:MM guest/minimal.bin
-rwxr-xr-x. 1 seolcu seolcu 142 11월 23일  HH:MM guest/multiplication.bin
-rwxr-xr-x. 1 seolcu seolcu 51  11월 23일  HH:MM guest/pmode_test.bin
-rwxr-xr-x. 1 seolcu seolcu 12K 11월 23일  HH:MM os-1k/kernel.bin
```

모든 파일이 존재하면 준비 완료! 아래의 시연 명령어들을 실행하면 됩니다.

---

## 시연 시나리오

모든 시연은 `kvm-vmm-x86` 디렉토리에서 `make run-<타겟>` 형식으로 실행합니다.

### 시연 1: 기본 리얼 모드 게스트

#### 1-1. Minimal Guest (가장 단순한 1바이트 게스트)
```bash
make run-minimal
```
**설명**: 단 1바이트(HLT 명령어)로 구성된 가장 단순한 게스트. VMM이 정상 동작하는지 확인.

**예상 결과**: 즉시 "Guest halted" 메시지와 함께 종료

---

#### 1-2. Hello Guest (문자열 출력)
```bash
make run-hello
```
**설명**: "Hello, KVM!" 메시지를 UART 포트(0x3f8)로 출력하는 게스트.

**예상 결과**: 
```
Hello, KVM!
```
출력 후 종료

---

#### 1-3. Counter Guest (숫자 출력)
```bash
make run-counter
```
**설명**: 0부터 9까지 순차적으로 출력하는 게스트.

**예상 결과**: 
```
0123456789
```
출력 후 종료

---

### 시연 2: 다중 vCPU (핵심 기능!)

#### 2개 게스트 동시 실행
```bash
make run-multi2
```

**설명**:
- **vCPU 0**: Multiplication guest가 " x = " 출력 (hypercall 사용)
- **vCPU 1**: Counter guest가 "0123456789" 출력 (UART 사용)
- **핵심**: 두 출력이 인터리브되어 나타남 → 진짜 병렬 실행!

**예상 결과** (개선된 버전 - 출력 버퍼링):
```
0123456789
[vCPU 0:multiplication] 2x1=2 2x2=4 2x3=6 ... 9x9=81
```
(각 vCPU의 출력이 줄 단위로 그룹화되어 매우 깔끔함)

**강조 포인트**:
- 각 vCPU가 독립적인 256KB 메모리 공간 사용
- vCPU 0: GPA 0x00000, vCPU 1: GPA 0x40000
- Real Mode에서 CS 레지스터로 주소 지정 (CS×16 + IP)
- 출력 버퍼링으로 다중 vCPU 출력을 라인 단위로 그룹화 (개선사항)

---

#### 4개 게스트 동시 실행 (최대 확장성)
```bash
make run-multi4
```

**설명**: 4개 vCPU가 각각 다른 프로그램을 동시에 실행
- vCPU 0: Counter (0-9)
- vCPU 1: Hello
- vCPU 2: Multiplication
- vCPU 3: Minimal (즉시 종료)

**예상 결과**: 4개 프로그램의 출력이 모두 섞여서 나옴

---

### 시연 3: 1K OS (보호 모드 및 페이징) - 9가지 프로그램!

#### 3-1. 구구단 출력
```bash
make run-1k-os-multiplication
```

**설명**: 
- Protected Mode + 페이징 활성화
- 4MB 메모리, GDT/IDT 설정
- 타이머 & 키보드 인터럽트 처리
- User space 프로그램 실행 (9개 프로그램!)

**예상 결과**:
```
=== 1K OS Menu ===
  1. Multiplication Table (2x1 ~ 9x9)
  2. Counter (0-9)
  3. Echo (interactive)
  4. Fibonacci Sequence
  5. Prime Numbers (up to 100)
  6. Calculator (+, -, *, /)
  7. Factorial (0! ~ 12!)
  8. GCD (Euclidean Algorithm)
  9. About 1K OS
  0. Exit

Select: 1

=== Multiplication Table ===
2*1=2 2*2=4 2*3=6 ... 9*9=81
```

---

#### 3-2. 카운터
```bash
make run-1k-os-counter
```

**예상 결과**:
```
=== Counter 0-9 ===
0 1 2 3 4 5 6 7 8 9
```

---

#### 3-3. 대화형 에코
```bash
make run-1k-os-echo
```

**설명**: 
- User space에서 OUT+IN hypercall로 키보드 입력 받기
- IOPL=3 설정으로 user space I/O 허용

**예상 결과**:
```
=== Echo Program (type 'quit' to exit) ===
$ Hello 1K OS
Echo: Hello 1K OS
$ This is amazing!
Echo: This is amazing!
$ quit
Exiting echo program
```

---

#### 3-4. Fibonacci 수열
```bash
make run-1k-os-fibonacci
```

**예상 결과**:
```
=== Fibonacci Sequence ===
Calculating Fibonacci numbers up to 89:
0 1 1 2 3 5 8 13 21 34 55 89
```

---

#### 3-5. 소수 찾기
```bash
make run-1k-os-primes
```

**예상 결과**:
```
=== Prime Numbers up to 100 ===
2 3 5 7 11 13 17 19 23 29
31 37 41 43 47 53 59 61 67 71
73 79 83 89 97
Total: 25 primes
```

---

#### 3-6. 계산기
```bash
make run-1k-os-calc
```

**설명**:
- 기본 사칙연산 (+, -, *, /)
- 대화형 입력으로 여러 계산 가능

**예상 결과**:
```
=== Simple Calculator ===
Enter expression (e.g., "10 + 5") or 'q' to quit:
$ 123 + 456 = 579
$ Exiting calculator...
```

---

#### 3-7. Factorial (0! ~ 12!)
```bash
make run-1k-os-factorial
```

**설명**:
- 팩토리얼 계산 (0! 부터 12!)
- 13! 이상은 32비트 오버플로 경고

**예상 결과**:
```
=== Factorial Calculator ===
0! = 1
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
11! = 39916800
12! = 479001600

Note: 13! and above overflow 32-bit integers
```

---

#### 3-8. GCD (최대공약수)
```bash
make run-1k-os-gcd
```

**설명**:
- 유클리드 호제법 (Euclidean Algorithm) 시연
- 5가지 예제 쌍 계산

**예상 결과**:
```
=== GCD Calculator (Euclidean Algorithm) ===
GCD(48, 18) = 6
GCD(100, 35) = 5
GCD(81, 27) = 27
GCD(123, 456) = 3
GCD(17, 19) = 1 (coprime)
```

---

#### 3-9. About 1K OS
```bash
make run-1k-os-about
```

**예상 결과**:
```
=== About 1K OS ===
1K OS: Operating System in 1000 Lines
Ported from RISC-V to x86 Protected Mode
Features:
  - Protected Mode with Paging
  - Keyboard and Timer Interrupts
  - Simple Shell
  - User Programs: 9 demos

Mini-KVM VMM Project
Educational hypervisor using KVM API

Exiting shell...
Thank you for using 1K OS!
```

---

## 시연 팁

### 1. 출력 정리
디버그 메시지가 너무 많으면:
```bash
make run-counter 2>&1 | grep -v "IO\|EXIT\|HC"
```

### 2. 타임아웃 설정
무한 대기 방지:
```bash
timeout 5s make run-1k-os-multiplication
```

### 3. 깔끔한 화면
시연 전에:
```bash
clear
```

---

## 발표 스크립트 예시

### 시연 2 (다중 vCPU) 시연 시
```
"이제 가장 인상적인 부분인 멀티 vCPU를 보여드리겠습니다.
두 개의 완전히 독립적인 프로그램이 동시에 실행됩니다.

[명령어 입력]
make run-multi2

보시다시피 두 프로그램의 출력이 섞여 나오는데,
이것은 진짜 병렬 실행이 일어나고 있다는 증거입니다.

각 vCPU는 256KB의 독립적인 메모리 공간을 가지고 있으며,
Real Mode의 세그먼트 주소 지정 방식을 사용합니다."
```

### 시연 3-3 (에코) 시연 시
```
"이 에코 프로그램은 특별한 의미가 있습니다.
오늘 발견하고 수정한 버그의 결과물이기 때문입니다.

문제는 user space의 getchar 함수가 OUT 명령어만 사용해서
입력을 전혀 받지 못했던 것이었습니다.

이를 OUT+IN 프로토콜로 수정하고,
IOPL=3을 설정해서 user space에서 I/O 명령어를 
실행할 수 있게 했습니다.

[명령어 입력]
make run-1k-os-echo

이제 입력이 정상적으로 에코되는 것을 볼 수 있습니다."
```

---

## 문제 해결

### 문제: "Permission denied" 또는 KVM 접근 불가
```bash
# KVM 모듈 확인
lsmod | grep kvm

# 권한 확인
ls -l /dev/kvm

# 그룹 추가 (필요시)
sudo usermod -aG kvm $USER
```

### 문제: 게스트가 실행 안 됨
```bash
# 전체 재빌드 및 실행
make clean all run-hello
```

### 문제: 1K OS 입력 안 받음
- `make run-1k-os-shell` 을 사용하여 대화형으로 입력하거나, `printf` 파이프라인을 사용하세요.
- 충분한 타임아웃 설정: `timeout 10s make run-1k-os-multiplication`

---

## 핵심 수치

발표 시 언급할 수 있는 통계:
- **코드 크기**: minimal 1바이트 ~ 1K OS 12KB
- **메모리**: Real Mode 256KB, Protected Mode 4MB
- **최대 vCPU**: 4개 동시 실행
- **하이퍼콜 종류**: 3가지 (PUTCHAR, GETCHAR, EXIT)
- **VM exits**: 간단한 게스트 ~10회, 1K OS ~5000회
- **1K OS 프로그램**: 9개 (구구단, 카운터, 에코, 피보나치, 소수, 계산기, 팩토리얼, GCD, About)

---

## 시연 체크리스트

시연 전 확인:
- [ ] 디렉토리 위치 확인 (`kvm-vmm-x86`)
- [ ] 빌드 완료 확인 (`make all` 실행)
- [ ] 터미널 폰트 크기 확대 (가독성)
- [ ] 화면 녹화/캡처 준비 (선택)

---

## 최근 개선사항 (2025-11-23)

### 1. 출력 버퍼링 개선
- **문제**: 다중 vCPU 실행 시 출력이 문자 단위로 섞여 읽기 어려움
- **해결**: 각 vCPU마다 512바이트 출력 버퍼 추가
- **효과**: 한 줄 단위로 출력이 그룹화되어 훨씬 읽기 편함

### 2. 성능 개선
- **Exit 한계값**: 10,000 → 100,000 (10배 증가)
- **타이머 주기**: 10ms → 100ms (10배 감소)
- **효과**: 1K OS 대화형 사용 시간 8초 → 약 100초 이상 가능

### 3. 게스트 프로그램 수정 (이전 작업)
- `hello.S`: UART I/O → Hypercall 방식으로 변경
- `multiplication.S`: 미정의 하이퍼콜 제거, 제대로 된 구구단 출력으로 수정

---

**준비 완료! 성공적인 발표 되시길 바랍니다!**
