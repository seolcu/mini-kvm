# Mini-KVM 데모 가이드

발표 시 직접 시연할 수 있는 완전한 가이드입니다.

---

## 사전 준비

### 1. 디렉토리 이동
```bash
cd ~/문서/코드/mini-kvm/kvm-vmm-x86
```

### 2. 프로젝트 빌드

모든 VMM, 게스트 프로그램 및 1K OS는 `make` 명령을 사용하여 빌드하고 실행할 수 있습니다.
`make all` 명령으로 모든 구성요소를 한 번에 빌드할 수 있습니다.

```bash
# 모든 구성요소 빌드 (VMM, 게스트, 1K OS)
make all
```

**빌드 확인**:

```bash
ls -lh kvm-vmm guest/* os-1k/kernel
```

**예상 결과**:
```
-rwxr-xr-x. 1 seolcu seolcu 25K 11월 23일  HH:MM kvm-vmm
-rwxr-xr-x. 1 seolcu seolcu 18  11월 23일  HH:MM guest/counter
-rwxr-xr-x. 1 seolcu seolcu 82  11월 23일  HH:MM guest/fibonacci
-rwxr-xr-x. 1 seolcu seolcu 79  11월 23일  HH:MM guest/hctest
-rwxr-xr-x. 1 seolcu seolcu 33  11월 23일  HH:MM guest/hello
-rwxr-xr-x. 1 seolcu seolcu 1   11월 23일  HH:MM guest/minimal
-rwxr-xr-x. 1 seolcu seolcu 142 11월 23일  HH:MM guest/multiplication
-rwxr-xr-x. 1 seolcu seolcu 51  11월 23일  HH:MM guest/pmode_test
-rwxr-xr-x. 1 seolcu seolcu 12K 11월 23일  HH:MM os-1k/kernel
```

모든 파일이 존재하면 준비 완료! 아래의 시연 명령어들을 실행하면 됩니다.

---

## 시연 시나리오

모든 시연은 `./kvm-vmm <게스트바이너리>` 형식으로 직접 실행합니다.

### 시연 1: 기본 리얼 모드 게스트

#### 1-1. Minimal Guest (가장 단순한 1바이트 게스트)
```bash
./kvm-vmm guest/minimal
```
**설명**: 단 1바이트(HLT 명령어)로 구성된 가장 단순한 게스트. VMM이 정상 동작하는지 확인.

**예상 결과**: 
```
[minimal] Thread started
[minimal] Guest halted after 1 exits
[minimal] Thread exiting (total exits: 1)

=== All vCPUs completed ===
```
즉시 종료 (인터럽트 없이 깔끔하게!)

---

#### 1-2. Hello Guest (문자열 출력)
```bash
./kvm-vmm guest/hello
```
**설명**: "Hello, KVM!" 메시지를 하이퍼콜로 출력하는 게스트.

**예상 결과**: 
```
[hello] Thread started
Hello, KVM!
[hello] Guest halted after 13 exits
[hello] Thread exiting (total exits: 13)

=== All vCPUs completed ===
```

---

#### 1-3. Counter Guest (숫자 출력)
```bash
./kvm-vmm guest/counter
```
**설명**: 0부터 9까지 순차적으로 출력하는 게스트.

**예상 결과**: 
```
[counter] Thread started
0123456789[counter] Guest halted after 11 exits
[counter] Thread exiting (total exits: 11)

=== All vCPUs completed ===
```

---

### 시연 2: 다중 vCPU (핵심 기능!)

#### 2개 게스트 동시 실행
```bash
./kvm-vmm guest/multiplication guest/counter
```

**설명**:
- **vCPU 0** (청록): Multiplication guest가 구구단 출력 (hypercall 사용)
- **vCPU 1** (초록): Counter guest가 "0123456789" 출력
- **핵심**: 두 출력이 **색상으로 구분**되며 인터리브됨 → 진짜 병렬 실행!

**예상 결과** (터미널에서 색상으로 구분):
```
0[청록]2[초록]1[청록]x[초록]2[청록]1[초록]3...
```
출력이 문자 단위로 섞이며, 각 vCPU의 출력이 서로 다른 색으로 표시됨

**강조 포인트**:
- 각 vCPU가 독립적인 256KB 메모리 공간 사용
- vCPU 0: GPA 0x00000, vCPU 1: GPA 0x40000
- Real Mode에서 CS 레지스터로 주소 지정 (CS×16 + IP)
- **색상 코딩**: 청록/초록/노랑/파랑으로 vCPU 구분 (빨강은 오류로 오인될 수 있어 제외)
- **즉각 출력**: 버퍼링 없이 character-by-character 출력으로 병렬성 극대화

---

#### 4개 게스트 동시 실행 (최대 확장성)
```bash
./kvm-vmm guest/counter guest/hello guest/multiplication guest/minimal
```

**설명**: 4개 vCPU가 각각 다른 프로그램을 동시에 실행
- vCPU 0 (청록): Counter (0-9)
- vCPU 1 (초록): Hello
- vCPU 2 (노랑): Multiplication
- vCPU 3 (파랑): Minimal (즉시 종료)

**예상 결과**: 
```
0[노랑]2[초록]H[청록]1[노랑]x[초록]e[청록]2...
[파랑][vCPU 3:minimal] Guest halted after 1 exits
```
4가지 색상으로 구분된 출력이 실시간으로 섞임!

---

### 시연 3: 1K OS (보호 모드 및 페이징) - 9가지 프로그램!

#### 3-1. 구구단 출력
```bash
printf '1\n0\n' | ./kvm-vmm --paging os-1k/kernel
```

**설명**: 
- Protected Mode + 페이징 활성화 (`--paging` 플래그)
- 4MB 메모리, GDT/IDT 설정, PSE (4MB 페이지) 사용
- 타이머 & 키보드 인터럽트 처리 (IRQCHIP 활성화)
- User space 프로그램 실행 (9개 프로그램!)

**예상 결과**:
```
=== 1K OS Menu ===
  1. Multiplication Table (2x1 ~ 9x9)
  2. Counter (0-9)
  3. Echo (interactive)
  4. Fibonacci Sequence
  5. Prime Numbers (up to 100)
  6. Calculator
  7. Factorial (0! ~ 12!)
  8. GCD (Greatest Common Divisor)
  9. About 1K OS
  0. Exit

Select: 

=== Multiplication Table ===
2*1=2 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 2*7=14 2*8=16 2*9=18 
3*1=3 3*2=6 3*3=9 3*4=12 3*5=15 ... 9*9=81 

(메뉴로 돌아간 후 0 입력으로 종료)
```

---

#### 3-2. 카운터
```bash
printf '2\n0\n' | ./kvm-vmm --paging os-1k/kernel
```

**예상 결과**:
```
=== Counter 0-9 ===
0 1 2 3 4 5 6 7 8 9
```

---

#### 3-3. 대화형 에코 (대화형 테스트 권장)
```bash
./kvm-vmm --paging os-1k/kernel
# 메뉴에서 3 선택 → 메시지 입력 → "quit" 입력 → 0으로 종료
```

**설명**: 
- User space에서 하이퍼콜로 키보드 입력 받기
- 인터럽트 기반 stdin 모니터링

**예상 결과**:
```
Select: 3

=== Echo Program ===
Type messages (type 'quit' to exit)
$ Hello
Echo: Hello
$ quit
Exiting echo program
```

---

#### 3-4. Fibonacci 수열
```bash
printf '4\n0\n' | ./kvm-vmm --paging os-1k/kernel
```

**예상 결과**:
```
=== Fibonacci Sequence (first 15 numbers) ===
F(0) = 0
F(1) = 1
F(2) = 1
F(3) = 2
F(4) = 3
F(5) = 5
F(6) = 8
F(7) = 13
F(8) = 21
F(9) = 34
F(10) = 55
F(11) = 89
F(12) = 144
F(13) = 233
F(14) = 377
```

---

#### 3-5. 소수 찾기
```bash
printf '5\n0\n' | ./kvm-vmm --paging os-1k/kernel
```

**예상 결과**:
```
=== Prime Numbers up to 100 ===
2 3 5 7 11 13 17 19 23 29 
31 37 41 43 47 53 59 61 67 71 
73 79 83 89 97 
Total: 25 primes
```

---

#### 3-6. 계산기 (입력 파싱 이슈 있음)
```bash
printf '6\n42 + 58\nq\n0\n' | ./kvm-vmm --paging os-1k/kernel
```

**설명**:
- 기본 사칙연산 (+, -, *, /)
- 공백으로 구분된 형식: "숫자 연산자 숫자"

**알려진 이슈**: 입력 파싱에 버그가 있어 제대로 동작하지 않을 수 있음 (1K OS 코드 문제)

---

#### 3-7. Factorial (0! ~ 12!)
```bash
printf '7\n0\n' | ./kvm-vmm --paging os-1k/kernel
```

**설명**:
- 팩토리얼 계산 (0! 부터 12!)
- 13! 이상은 32비트 오버플로 경고

**예상 결과**:
```
=== Factorial Calculator ===
Calculating factorials for n = 0 to 12

0! = 1
1! = 1
2! = 2
3! = 6
4! = 24
5! = 120
6! = 720
7! = 5040
8! = 40320
9! = 362880
10! = 3628800
11! = 39916800
12! = 479001600

Note: 13! = 6227020800 (overflow on 32-bit)
```

---

#### 3-8. GCD (최대공약수)
```bash
printf '8\n0\n' | ./kvm-vmm --paging os-1k/kernel
```

**설명**:
- 유클리드 호제법 (Euclidean Algorithm) 시연
- 여러 예제 쌍 계산

**예상 결과**:
```
=== GCD (Greatest Common Divisor) ===
Examples of Euclidean algorithm:

GCD(48, 18) = 6
GCD(100, 75) = 25
GCD(123, 456) = 3
GCD(17, 19) = 1
GCD(1071, 462) = 21
```

---

#### 3-9. About 1K OS
```bash
printf '9\n0\n' | ./kvm-vmm --paging os-1k/kernel
```

**예상 결과**:
```
=== About 1K OS ===
1K OS: Operating System in 1000 Lines
Ported from RISC-V to x86 Protected Mode
Features:
  - Protected Mode with Paging
  - Keyboard and Timer Interrupts
  - Simple Shell
  - User Programs: 9 demos

Mini-KVM VMM Project
Educational hypervisor using KVM API
```

---

## 시연 팁

### 1. Verbose 모드 (디버깅용)
VM exit, I/O, 하이퍼콜 상세 로그 출력:
```bash
./kvm-vmm --verbose guest/hello
```

### 2. 타임아웃 설정
무한 대기 방지:
```bash
timeout 5s ./kvm-vmm --paging os-1k/kernel
```

### 3. 깔끔한 화면
시연 전에:
```bash
clear
```

### 4. 색상 출력 확인
다중 vCPU 실행 시 터미널이 색상을 지원하는지 확인:
```bash
echo $TERM  # xterm-256color 등이 나와야 함
```

---

## 발표 스크립트 예시

### 시연 2 (다중 vCPU) 시연 시
```
"이제 가장 인상적인 부분인 멀티 vCPU를 보여드리겠습니다.
두 개의 완전히 독립적인 프로그램이 동시에 실행됩니다.

[명령어 입력]
./kvm-vmm guest/multiplication guest/counter

보시다시피 두 프로그램의 출력이 색상으로 구분되어 섞여 나오는데,
이것은 진짜 병렬 실행이 일어나고 있다는 증거입니다.

각 vCPU는 256KB의 독립적인 메모리 공간을 가지고 있으며,
Real Mode의 세그먼트 주소 지정 방식을 사용합니다.

출력이 문자 단위로 실시간 섞이는 것을 보실 수 있는데,
이는 버퍼링을 제거해서 병렬성을 극대화한 결과입니다."
```

### 시연 3-3 (에코) 시연 시
```
"이 에코 프로그램은 특별한 의미가 있습니다.
개발 과정에서 발견하고 수정한 버그의 결과물이기 때문입니다.

문제는 user space의 getchar 함수가 OUT 명령어만 사용해서
입력을 전혀 받지 못했던 것이었습니다.

이를 OUT+IN 프로토콜로 수정하고,
IOPL=3을 설정해서 user space에서 I/O 명령어를 
실행할 수 있게 했습니다.

[명령어 입력]
./kvm-vmm --paging os-1k/kernel
(메뉴에서 3 입력)

이제 입력이 정상적으로 에코되는 것을 볼 수 있습니다."
```

---

## 문제 해결

### 문제: "Permission denied" 또는 KVM 접근 불가
```bash
# KVM 모듈 확인
lsmod | grep kvm

# 권한 확인
ls -l /dev/kvm

# 그룹 추가 (필요시)
sudo usermod -aG kvm $USER
```

### 문제: 게스트가 실행 안 됨
```bash
# 전체 재빌드
make clean all

# 실행
./kvm-vmm guest/hello
```

### 문제: 1K OS 입력 안 받음
- 대화형 입력이 필요한 경우: `./kvm-vmm --paging os-1k/kernel`
- 자동화된 입력: `printf '1\n0\n' | ./kvm-vmm --paging os-1k/kernel`
- 충분한 타임아웃 설정: `timeout 10s ./kvm-vmm --paging os-1k/kernel`

### 문제: Real Mode 게스트가 멈춤
- **해결됨!** 이전에는 IRQCHIP 때문에 멈췄지만, 현재는 Real Mode에서 IRQCHIP을 생성하지 않아 즉시 종료됨
- Protected Mode에서만 `--paging` 플래그로 IRQCHIP 활성화

---

## 핵심 수치

발표 시 언급할 수 있는 통계:
- **코드 크기**: minimal 1바이트 ~ 1K OS 12KB
- **메모리**: Real Mode 256KB, Protected Mode 4MB
- **최대 vCPU**: 4개 동시 실행
- **하이퍼콜 종류**: 3가지 (PUTCHAR, GETCHAR, EXIT)
- **VM exits**: 간단한 게스트 ~10회, 1K OS ~5000회
- **1K OS 프로그램**: 9개 (구구단, 카운터, 에코, 피보나치, 소수, 계산기, 팩토리얼, GCD, About)

---

## 시연 체크리스트

시연 전 확인:
- [ ] 디렉토리 위치 확인 (`kvm-vmm-x86`)
- [ ] 빌드 완료 확인 (`make all` 실행)
- [ ] 터미널 폰트 크기 확대 (가독성)
- [ ] 화면 녹화/캡처 준비 (선택)

---

## 최근 개선사항 (2025-11-23)

### 1. VMM Hang 문제 완전 해결
- **문제**: Real Mode 게스트가 실행 후 종료되지 않고 무한정 대기
- **원인**: 불필요한 IRQCHIP과 timer 인터럽트가 HLT를 방해
- **해결**: 
  - Protected Mode에서만 IRQCHIP 생성 (`init_kvm(bool need_irqchip)`)
  - Timer/stdin 스레드도 Protected Mode에서만 시작
- **효과**: 모든 Real Mode 프로그램 즉시 실행/종료 (< 100ms)

### 2. 색상 출력 개선
- **개선 전**: 모든 출력에 색상 적용 (단일 vCPU에서도 불필요)
- **개선 후**:
  - **단일 vCPU**: 깔끔한 `[guest_name]` 프리픽스, 색상 없음
  - **다중 vCPU**: 청록/초록/노랑/파랑으로 각 vCPU 구분
  - **색상 변경**: vCPU 0을 빨강에서 청록으로 변경 (오류 메시지로 오인 방지)
- **효과**: 가독성 향상, 병렬 실행 시각화, 직관적 색상 구분

### 3. 즉각 출력 (Unbuffered Output)
- **변경**: 출력 버퍼링 제거 → character-by-character 즉시 출력
- **효과**: 다중 vCPU 병렬 실행 효과가 더 명확히 보임

### 4. Verbose 모드 추가
- `--verbose` 플래그: VM exit, I/O, 하이퍼콜 상세 로그
- 일반 사용자는 깨끗한 출력, 개발자는 상세 디버깅 가능

### 5. 실행 방식 개선
- **현재**: `./kvm-vmm <guest.bin>` (직접 실행)
- **효과**: 직관적이고 유연한 사용법으로 다양한 옵션 조합 가능

---

**준비 완료! 성공적인 발표 되시길 바랍니다!**
